<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Z.A.M.&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/taiaiac.gitee.io/css/images/logo.png">
  
  <title>
    
      vue-router | Z. A. M. 的学习笔记
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/taiaiac.gitee.io/css/style.css">

  
    
<link rel="stylesheet" href="/taiaiac.gitee.io/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/taiaiac.gitee.io/js/qrious.js"></script>

  
  
    
<script src="/taiaiac.gitee.io/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 5.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/taiaiac.gitee.io/">
      <div class="logo"></div>
      <span>Z. A. M. 的学习笔记</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/taiaiac.gitee.io/" class="item-link">主页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/taiaiac.gitee.io/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/taiaiac.gitee.io/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/taiaiac.gitee.io/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/taiaiac.gitee.io/" class="menu-link">主页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/taiaiac.gitee.io/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/taiaiac.gitee.io/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/taiaiac.gitee.io/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>vue-router</h2>
  <p class="post-date">2020-12-30</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>要学习 vue-router 就要先知道这里的路由是什么？为什么我们不能像原来一样直接用<a></a>标签编写链接哪？vue-router 如何使用？常见路由操作有哪些？等等这些问题，就是本篇要探讨的主要问题。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-0ea528f387ba9366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/989/format/webp" alt="img"></p>
<h2 id="二、vue-router-是什么"><a href="#二、vue-router-是什么" class="headerlink" title="二、vue-router 是什么"></a>二、vue-router 是什么</h2><p>这里的路由并不是指我们平时所说的硬件路由器，<strong>这里的路由就是 SPA（单页应用）的路径管理器</strong>。再通俗的说，vue-router 就是 WebApp 的链接路径管理系统。<br>vue-router 是 Vue.js 官方的路由插件，它和 vue.js 是深度集成的，适合用于构建单页面应用。vue 的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在 vue-router 单页面应用中，则是路径之间的切换，也就是组件的切换。<strong>路由模块的本质 就是建立起 url 和页面之间的映射关系</strong>。</p>
<p>至于我们为啥不能用 a 标签，这是因为用 Vue 做的都是单页应用（<strong>当你的项目准备打包时，运行<code>npm run build</code>时，就会生成 dist 文件夹，这里面只有静态资源和一个 indexer 页面</strong>），所以你写的<a></a>标签是不起作用的，你必须使用 vue-router 来进行管理。</p>
<h2 id="三、vue-router-实现原理"><a href="#三、vue-router-实现原理" class="headerlink" title="三、vue-router 实现原理"></a>三、vue-router 实现原理</h2><p>SPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。<strong>单页面应用(SPA)的核心之一是: 更新视图而不重新请求页面</strong>;vue-router 在实现单页面前端路由时，提供了两种方式：Hash 模式和 History 模式；根据 mode 参数来决定采用哪一种方式。</p>
<h3 id="1、Hash-模式："><a href="#1、Hash-模式：" class="headerlink" title="1、Hash 模式："></a>1、Hash 模式：</h3><p><strong>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</strong> hash（#）是 URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说<strong>hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面</strong>；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说<strong>Hash 模式通过锚点值的改变，根据不同的值，渲染指定 DOM 位置的不同数据。hash 模式的原理是 onhashchange 事件(监测 hash 值变化)，可以在 window 对象上监听这个事件</strong>。</p>
<h3 id="2、History-模式："><a href="#2、History-模式：" class="headerlink" title="2、History 模式："></a>2、History 模式：</h3><p>由于 hash 模式会在 url 中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,<strong>这种模式充分利用了 html5 history interface 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js文件中</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  routes: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当你使用 history 模式时，URL 就像正常的 url，例如 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://yoursite.com/user/id">http://yoursite.com/user/id</a>，比较好看！<br>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://oursite.com/user/id">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。<br>所以呢，<strong>你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> routes = [</span><br><span class="line"> &#123;path: <span class="string">&quot;/&quot;</span>, name: <span class="string">&quot;homeLink&quot;</span>, component:Home&#125;</span><br><span class="line"> &#123;path: <span class="string">&quot;/register&quot;</span>, name: <span class="string">&quot;registerLink&quot;</span>, component: Register&#125;,</span><br><span class="line"> &#123;path: <span class="string">&quot;/login&quot;</span>, name: <span class="string">&quot;loginLink&quot;</span>, component: Login&#125;,</span><br><span class="line"> &#123;path: <span class="string">&quot;*&quot;</span>, redirect: <span class="string">&quot;/&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>此处就设置如果 URL 输入错误或者是 URL 匹配不到任何静态资源，就自动跳到到 Home 页面</p>
<h3 id="3、使用路由模块来实现页面跳转的方式"><a href="#3、使用路由模块来实现页面跳转的方式" class="headerlink" title="3、使用路由模块来实现页面跳转的方式"></a>3、使用路由模块来实现页面跳转的方式</h3><ul>
<li>方式 1：直接修改地址栏</li>
<li>方式 2：this.$router.push(‘路由地址’)</li>
<li>方式 3：<code>&lt;router-link to=&quot;路由地址&quot;&gt;&lt;/router-link&gt;</code></li>
</ul>
<h2 id="四、vue-router-使用方式"><a href="#四、vue-router-使用方式" class="headerlink" title="四、vue-router 使用方式"></a>四、vue-router 使用方式</h2><p>1:下载 <code>npm i vue-router -S</code><br>2:在 main.js 中引入 <code>import VueRouter from &#39;vue-router&#39;</code>;<br>3:安装插件<code>Vue.use(VueRouter)</code>;<br>4:创建路由对象并配置路由规则 <code>let router = new VueRouter(&#123;routes:[&#123;path:&#39;/home&#39;,component:Home&#125;]&#125;)</code>;<br>5:将其路由对象传递给 Vue 的实例，options 中加入 <code>router:router</code><br>6:在 app.vue 中留坑 <code>&lt;router-view&gt;&lt;/router-view&gt;</code></p>
<p><img src="C:\Users\52862\AppData\Roaming\Typora\typora-user-images\image-20201029170802471.png" alt="image-20201029170802471"></p>
<p><img src="C:\Users\52862\AppData\Roaming\Typora\typora-user-images\image-20201029170812839.png" alt="image-20201029170812839"></p>
<p>具体实现请看如下代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js文件中引入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//主体</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./components/app.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./components/home.vue&#x27;</span></span><br><span class="line"><span class="comment">//安装插件</span></span><br><span class="line">Vue.use(VueRouter) <span class="comment">//挂载属性</span></span><br><span class="line"><span class="comment">//创建路由对象并配置路由规则</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">//一个个对象</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: Home &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//new Vue 启动</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">//让vue知道我们的路由规则</span></span><br><span class="line">  router: router, <span class="comment">//可以简写router</span></span><br><span class="line">  render: <span class="function">(<span class="params">c</span>) =&gt;</span> c(App),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>最后记得在在 app.vue 中“留坑”</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.vue中</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- 留坑，非常重要 --&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="五、-vue-router-参数传递"><a href="#五、-vue-router-参数传递" class="headerlink" title="五、 vue-router 参数传递"></a>五、 vue-router 参数传递</h2><p>声明式的导航<code>&lt;router-link :to=&quot;...&quot;&gt;</code>和编程式的导航<code>router.push(...)</code>都可以传参，本文主要介绍前者的传参方法，同样的规则也适用于编程式的导航。</p>
<h3 id="1-用-name-传递参数"><a href="#1-用-name-传递参数" class="headerlink" title="1.用 name 传递参数"></a>1.用 name 传递参数</h3><p>在路由文件 src/router/index.js 里配置 name 属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">      component: Hello</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>模板里(src/App.vue)用<code>$route.name</code>来接收 比如：<code>&lt;p&gt;&#123;&#123; $route.name&#125;&#125;&lt;/p&gt;</code></p>
<h3 id="2-通过-lt-router-link-gt-标签中的-to-传参"><a href="#2-通过-lt-router-link-gt-标签中的-to-传参" class="headerlink" title="2 通过&lt;router-link&gt; 标签中的 to 传参"></a>2 通过<code>&lt;router-link&gt;</code> 标签中的 to 传参</h3><p>这种传参方法的基本语法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link <span class="symbol">:to=<span class="string">&quot;&#123;name:xxx,params:&#123;key:value&#125;&#125;&quot;</span>&gt;valueString&lt;/router-link&gt;</span></span><br></pre></td></tr></table></figure>
<p>比如先在 src/App.vue 文件中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;hi1&#x27;,params:&#123;username:&#x27;jspang&#x27;,id:&#x27;555&#x27;&#125;&#125;&quot;</span>&gt;</span>Hi页面1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后把 src/router/index.js 文件里给 hi1 配置的路由起个 name,就叫 hi1.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attribute">path</span>:<span class="string">&#x27;/hi1&#x27;</span>,name:<span class="string">&#x27;hi1&#x27;</span>,component:Hi1&#125;</span><br></pre></td></tr></table></figure>
<p>最后在模板里(src/components/Hi1.vue)用<code>$route.params.username</code>进行接收.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="variable">$route</span>.params.username&#125;&#125;-&#123;&#123;<span class="variable">$route</span>.params.id&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-利用-url-传递参数—-在配置文件里以冒号的形式设置参数。"><a href="#3-利用-url-传递参数—-在配置文件里以冒号的形式设置参数。" class="headerlink" title="3 利用 url 传递参数—-在配置文件里以冒号的形式设置参数。"></a>3 利用 url 传递参数—-在配置文件里以冒号的形式设置参数。</h3><p>我们在/src/router/index.js 文件里配置路由</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">path</span>:<span class="string">&#x27;/params/:newsId/:newsTitle&#x27;</span>,</span><br><span class="line">    component:Params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要传递参数是新闻 ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。</p>
<p>在 src/components 目录下建立我们 params.vue 组件，也可以说是页面。我们在页面里输出了 url 传递的的新闻 ID 和新闻标题。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>新闻ID：&#123;&#123; $route.params.newsId&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>新闻标题：&#123;&#123; $route.params.newsTitle&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;params&#x27;</span>,</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      msg: <span class="string">&#x27;params page&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 App.vue 文件里加入我们的<code>&lt;router-view&gt;</code>标签。这时候我们可以直接利用 url 传值了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to&#x3D;&quot;&#x2F;params&#x2F;198&#x2F;jspang website is very good&quot;&gt;params&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-使用-path-来匹配路由，然后通过-query-来传递参数"><a href="#4-使用-path-来匹配路由，然后通过-query-来传递参数" class="headerlink" title="4. 使用 path 来匹配路由，然后通过 query 来传递参数"></a>4. 使用 path 来匹配路由，然后通过 query 来传递参数</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name:&#x27;Query&#x27;,query: &#123; queryId:  status &#125;&#125;&quot;</span> &gt;</span></span><br><span class="line">     router-link跳转Query</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应路由配置：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">path</span>: <span class="string">&#x27;/query&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;Query&#x27;</span>,</span><br><span class="line">  component: Query</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是我们可以获取参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$route.query.queryId</span><br></pre></td></tr></table></figure>
<h2 id="六、vue-router-配置子路由-二级路由"><a href="#六、vue-router-配置子路由-二级路由" class="headerlink" title="六、vue-router 配置子路由(二级路由)"></a>六、vue-router 配置子路由(二级路由)</h2><p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-efce15514ae3acdb?imageMogr2/auto-orient/strip%7CimageView2/2/w/619/format/webp" alt="img"></p>
<p>image</p>
<p>**如何实现下图效果(H1 页面和 H2 页面嵌套在主页中)**？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-1d309ac2e4ef990c?imageMogr2/auto-orient/strip%7CimageView2/2/w/621/format/webp" alt="img"></p>
<p>image</p>
<p>1.首先用<code>&lt;router-link&gt;</code>标签增加了两个新的导航链接</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;HelloWorld&#x27;&#125;&quot;</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;H1&#x27;&#125;&quot;</span>&gt;</span>H1页面<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;H2&#x27;&#125;&quot;</span>&gt;</span>H2页面<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.在 HelloWorld.vue 加入<code>&lt;router-view&gt;</code>标签，给子模板提供插入位置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.在 components 目录下新建两个组件模板 H1.vue 和 H2.vue<br>两者内容类似，以下是 H1.vue 页面内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        msg: <span class="string">&#x27;I am H1 page,Welcome to H1&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>修改 router/index.js 代码，子路由的写法是在原有的路由配置下加入 children 字段。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">    component: HelloWorld,</span><br><span class="line">    children: [&#123;path: <span class="string">&#x27;/h1&#x27;</span>, name: <span class="string">&#x27;H1&#x27;</span>, component: H1&#125;,<span class="comment">//子路由的&lt;router-view&gt;必须在HelloWorld.vue中出现</span></span><br><span class="line">      &#123;path: <span class="string">&#x27;/h2&#x27;</span>, name: <span class="string">&#x27;H2&#x27;</span>, component: H2&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="七、单页面多路由区域操作"><a href="#七、单页面多路由区域操作" class="headerlink" title="七、单页面多路由区域操作"></a>七、单页面多路由区域操作</h2><p>在一个页面里我们有两个以上<code>&lt;router-view&gt;</code>区域，我们通过配置路由的 js 文件，来操作这些区域的内容</p>
<p>1.App.vue 文件，在<code>&lt;router-view&gt;</code>下面新写了两行<code>&lt;router-view&gt;</code>标签,并加入了些 CSS 样式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;HelloWorld&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>H1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;H1&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>H2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left;width:50%;background-color:#ccc;height:300px;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:right;width:50%;background-color:yellowgreen;height:300px;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.需要在路由里配置这三个区域，配置主要是在 components 字段里进行</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span> <span class="selector-tag">new</span> <span class="selector-tag">Router</span>(&#123;</span><br><span class="line">    <span class="attribute">routes</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">        components: &#123;default: HelloWorld,</span><br><span class="line">          left:H1,//显示H1组件内容<span class="string">&#x27;I am H1 page,Welcome to H1&#x27;</span></span><br><span class="line">          right:H2//显示H2组件内容<span class="string">&#x27;I am H2 page,Welcome to H2&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">path</span>: <span class="string">&#x27;/h1&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;H1&#x27;</span>,</span><br><span class="line">        components: &#123;default: HelloWorld,</span><br><span class="line">          left:H2,//显示H2组件内容</span><br><span class="line">          right:H1//显示H1组件内容</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>上边的代码我们编写了两个路径，一个是默认的‘/’，另一个是‘/Hi’.在两个路径下的 components 里面，我们对三个区域都定义了显示内容。最后页面展示如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-f4f4f08651834c8e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>image</p>
<h2 id="八-route-和-router-的区别"><a href="#八-route-和-router-的区别" class="headerlink" title="八.$route 和 $router 的区别"></a>八.<code>$route</code> 和 <code>$router</code> 的区别</h2><p>我们先将这两者 console.log 打印出来：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-cb30e26e1485c06a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/458/format/webp" alt="img"></p>
<p>image</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-f88eea882545a2e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/722/format/webp" alt="img"></p>
<p>image</p>
<p><strong>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。</strong></p>
<p><strong>① <code>$route.path</code></strong><br>字符串，对应当前路由的路径，总是解析为绝对路径，如 “/order”。</p>
<p><strong>② <code>$route.params</code></strong><br>一个 key/value 对象，包含了 动态片段 和 全匹配片段，<br>如果没有路由参数，就是一个空对象。</p>
<p><strong>③ <code>$route.query</code></strong><br>一个 key/value 对象，表示 URL 查询参数。<br>例如，对于路径 /foo?user=1，则有 $route.query.user 为 1，<br>如果没有查询参数，则是个空对象。</p>
<p><strong>④ <code>$route.hash</code></strong><br>当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。</p>
<p><strong>⑤ <code>$route.fullPath</code></strong><br>完成解析后的 URL，包含查询参数和 hash 的完整路径。</p>
<p><strong>⑥ <code>$route.matched</code></strong><br>数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</p>
<p><strong>⑦ <code>$route.name</code> 当前路径名字</strong></p>
<p><strong>$router 是“路由实例”对象，即使用 new VueRouter 创建的实例，包括了路由的跳转方法，钩子函数等。</strong></p>
<p><strong>$router 常见跳转方法:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;button <span class="meta">@click</span>=<span class="string">&quot;goToMenu&quot;</span> <span class="class"><span class="keyword">class</span>=&quot;<span class="title">btn</span> <span class="title">btn</span>-<span class="title">success</span>&quot;&gt;<span class="title">Let</span>&#x27;<span class="title">s</span> <span class="title">order</span>！&lt;<span class="type">/button</span>&gt;</span></span><br><span class="line">.....</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">      goToMenu()&#123;</span><br><span class="line">        <span class="keyword">this</span>.$router.go(-<span class="number">1</span>)<span class="comment">//跳转到上一次浏览的页面</span></span><br><span class="line">        <span class="keyword">this</span>.$router.replace(<span class="string">&#x27;/menu&#x27;</span>)<span class="comment">//指定跳转的地址</span></span><br><span class="line">        <span class="keyword">this</span>.$router.replace(&#123;name:<span class="string">&#x27;menuLink&#x27;</span>&#125;)<span class="comment">//指定跳转路由的名字下</span></span><br><span class="line">        <span class="keyword">this</span>.$router.push(<span class="string">&#x27;/menu&#x27;</span>)<span class="comment">//通过push进行跳转</span></span><br><span class="line">        <span class="keyword">this</span>.$router.push(&#123;name:<span class="string">&#x27;menuLink&#x27;</span>&#125;)<span class="comment">//通过push进行跳转路由的名字下</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>$router.push</code>和<code>$router.replace</code>的区别</strong>：</p>
<ul>
<li>使用 push 方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。</li>
<li>使用 replace 方法不会向 history 添加新记录，而是替换掉当前的 history 记录，即当 replace 跳转到的网页后，‘后退’按钮不能查看之前的页面。</li>
</ul>
<h2 id="九、-如何设置-404-页面"><a href="#九、-如何设置-404-页面" class="headerlink" title="九、 如何设置 404 页面"></a>九、 如何设置 404 页面</h2><p>用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示页面，这个页面就是我们常说的 404 页面。vue-router 也为我们提供了这样的机制。</p>
<ol>
<li>设置我们的路由配置文件（/src/router/index.js）</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attribute">path</span>:<span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">   component:Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 path:’*‘就是输入地址不匹配时，自动显示出 Error.vue 的文件内容</p>
<ol>
<li>在/src/components/文件夹下新建一个 Error.vue 的文件。简单输入一些有关错误页面的内容。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      msg: <span class="string">&#x27;Error:404&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时我们随意输入一个错误的地址时，便会自动跳转到 404 页面</p>
<h2 id="十、路由守卫"><a href="#十、路由守卫" class="headerlink" title="十、路由守卫"></a>十、路由守卫</h2><h3 id="1-导航守卫是什么"><a href="#1-导航守卫是什么" class="headerlink" title="1.导航守卫是什么"></a><strong>1.导航守卫是什么</strong></h3><p>官方这么说：</p>
<blockquote>
<p><em>正如其名，</em><code>*vue-router*</code><em>提供的导航守卫主要用来通过跳转或取消的方式守卫导航。</em></p>
</blockquote>
<p>好吧，看不懂，就好（当）好（废）理（话）解（吧）下。其实，导航守卫就是路由跳转过程中的一些钩子函数，再直白点路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。</p>
<h3 id="2-导航守卫全解析"><a href="#2-导航守卫全解析" class="headerlink" title="2.导航守卫全解析"></a><strong>2.导航守卫全解析</strong></h3><p>先看一个钩子函数执行后输出的顺序截图吧，一般讲解都会在之后呈现，给大家换种思路（也就是先预习再学习最后复习）</p>
<p><img src="https://pic4.zhimg.com/80/v2-c3a67a5eb0b8da4936a6b57ef8c48783_720w.jpg" alt="img"></p>
<p>好吧不知道的估计看不懂吧！不过我希望你能看到一个点能多倒回来看看这个顺序，前方干货预警</p>
<hr>
<p><strong>导航守卫分为</strong>：全局的、单个路由独享的、组件内的三种。分别来看一下：</p>
<p>【全局的】：是指路由实例上直接操作的钩子函数，他的特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数，如下的写法。钩子函数按执行顺序包括 beforeEach、beforeResolve（2.5+）、afterEach 三个（以下的钩子函数都是按执行顺序讲解的）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>[beforeEach]：在路由跳转前触发，参数包括 to,from,next（参数会单独介绍）三个，这个钩子作用主要是用于登录验证，也就是路由还没跳转提前告知，以免跳转了再通知就为时已晚。</p>
<p>[beforeResolve]（2.5+）：这个钩子和 beforeEach 类似，也是路由跳转前触发，参数也是 to,from,next 三个，和 beforeEach 区别官方解释为：</p>
<blockquote>
<p>区别是在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后</strong>，解析守卫就被调用。</p>
</blockquote>
<p>即在 beforeEach 和 组件内 beforeRouteEnter 之后，afterEach 之前调用。</p>
<p>[afterEach]：和 beforeEach 相反，他是在路由跳转完成后触发，参数包括 to,from 没有了 next（参数会单独介绍）,他发生在 beforeEach 和 beforeResolve 之后，beforeRouteEnter（组件内守卫，后讲）之前。</p>
<p>【路由独享的】是指在单个路由配置的时候也可以设置的钩子函数，其位置就是下面示例中的位置，也就是像 Foo 这样的组件都存在这样的钩子函数。目前他只有一个钩子函数 beforeEnter：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>[beforeEnter]：和 beforeEach 完全相同，如果都设置则在 beforeEach 之后紧随执行，参数 to、from、next</p>
<p>【组件内的】：是指在组件内执行的钩子函数，类似于组件内的生命周期，相当于为配置路由的组件添加的生命周期钩子函数。钩子函数按执行顺序包括 beforeRouteEnter、beforeRouteUpdate (2.2+)、beforeRouteLeave 三个，执行位置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>[beforeRouteEnter]：路由进入之前调用，参数包括 to，from，next。该钩子在全局守卫 beforeEach 和独享守卫 beforeEnter 之后，全局 beforeResolve 和全局 afterEach 之前调用，要注意的是该守卫内访问不到组件的实例，也就是 this 为 undefined，也就是他在 beforeCreate 生命周期前触发。在这个钩子函数中，可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数，可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用 next 并在回调中通过 vm 访问组件实例进行赋值等操作，（next 中函数的调用在 mounted 之后：为了确保能对组件实例的完整访问）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// 这里还无法访问到组件实例，this === undefined</span></span><br><span class="line">  next( <span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[beforeRouteUpdate] (v 2.2+)：在当前路由改变时，并且该组件被复用时调用，可以通过 this 访问实例。参数包括 to，from，next。可能有的同学会疑问，what is 路由改变 or what is 组件被复用？</p>
<ul>
<li>对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，组件实例会被复用，该守卫会被调用</li>
<li>当前路由 query 变更时，该守卫会被调用</li>
</ul>
<p>[beforeRouteLeave]：导航离开该组件的对应路由时调用，可以访问组件实例<code>this</code>，参数包括 to，from，next。</p>
<p>至此，所有钩子函数介绍完毕。</p>
<p>屡一下哈：</p>
<p><strong>全局路由钩子：beforeEach(to,from, next)、beforeResolve(to,from, next)、afterEach(to,from)；</strong></p>
<p><strong>独享路由钩子：beforeEnter(to,from, next)；</strong></p>
<p><strong>组件内路由钩子：beforeRouteEnter(to,from, next)、beforeRouteUpdate(to,from, next)、beforeRouteLeave(to,from, next)</strong></p>
<p>不知道你是否还记得 to、from、next 这三个参数</p>
<p>下面请重头把这几个钩子函数的参数看一遍，细心的同学可以看见在 afterEach 钩子中参数没有 next，为什么呢？</p>
<h3 id="3-导航守卫回调参数"><a href="#3-导航守卫回调参数" class="headerlink" title="3.导航守卫回调参数"></a><strong>3.导航守卫回调参数</strong></h3><p>to：目标路由对象；</p>
<p>from：即将要离开的路由对象；</p>
<p>next：他是最重要的一个参数，他相当于佛珠的线，把一个一个珠子逐个串起来。以下注意点务必牢记：</p>
<p>1.但凡涉及到有 next 参数的钩子，必须调用 next() 才能继续往下执行下一个钩子，否则路由跳转等会停止。</p>
<p>2.如果要中断当前的导航要调用 next(false)。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到<code>from</code>路由对应的地址。（主要用于登录验证不通过的处理）</p>
<p>3.当然 next 可以这样使用，next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。意思是当前的导航被中断，然后进行一个新的导航。可传递的参数与<a href="https://link.zhihu.com/?target=https://router.vuejs.org/zh/guide/essentials/navigation.html">router.push</a>中选项一致。</p>
<p>4.在 beforeRouteEnter 钩子中 next((vm)=&gt;{})内接收的回调函数参数为当前组件的实例 vm，这个回调函数在生命周期 mounted 之后调用，也就是，他是所有导航守卫和生命周期函数最后执行的那个钩子。</p>
<p>5.next(error): (v2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <code>router.onError()</code> 注册过的回调。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a><strong>4.总结</strong></h3><p>好了，还记得那个截图吗，我们再看一遍</p>
<p><img src="https://pic2.zhimg.com/80/v2-8aa859dad60cd6b86f960070233771d5_720w.jpg" alt="img"></p>
<p>我们最后屡一下顺序：</p>
<p><strong>当点击切换路由时：beforeRouterLeave–&gt;beforeEach–&gt;beforeEnter–&gt;beforeRouteEnter–&gt;beforeResolve–&gt;afterEach–&gt;beforeCreate–&gt;created–&gt;beforeMount–&gt;mounted–&gt;beforeRouteEnter 的 next 的回调</strong></p>
<p><strong>当路由更新时：beforeRouteUpdate</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">记住参数或查询的改变并不会触发进入/离开的导航守卫。你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。</span><br><span class="line"></span><br><span class="line">全局前置守卫</span><br><span class="line">你可以使用 <span class="selector-tag">router</span><span class="selector-class">.beforeEach</span> 注册一个全局前置守卫：</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 <span class="selector-tag">resolve</span> 完之前一直处于 等待中。</span><br><span class="line"></span><br><span class="line">每个守卫方法接收三个参数：</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">to</span>: <span class="selector-tag">Route</span>: 即将要进入的目标 路由对象</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">from</span>: <span class="selector-tag">Route</span>: 当前导航正要离开的路由</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">next</span>: <span class="selector-tag">Function</span>: 一定要调用该方法来 <span class="selector-tag">resolve</span> 这个钩子。执行效果依赖 <span class="selector-tag">next</span> 方法的调用参数。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">next</span>(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <span class="selector-tag">confirmed</span> (确认的)。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">next</span>(<span class="selector-tag">false</span>): 中断当前的导航。如果浏览器的 <span class="selector-tag">URL</span> 改变了 (可能是用户手动或者浏览器后退按钮)，那么 <span class="selector-tag">URL</span> 地址会重置到 <span class="selector-tag">from</span> 路由对应的地址。</span><br><span class="line"></span><br><span class="line">next(&#x27;/&#x27;) 或者 next(&#123; path: &#x27;/&#x27; &#125;): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: &#x27;home&#x27; 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">next</span>(<span class="selector-tag">error</span>): (2.4.0+) 如果传入 <span class="selector-tag">next</span> 的参数是一个 <span class="selector-tag">Error</span> 实例，则导航会被终止且该错误会被传递给 <span class="selector-tag">router</span><span class="selector-class">.onError</span>() 注册过的回调。</span><br><span class="line"></span><br><span class="line">确保要调用 <span class="selector-tag">next</span> 方法，否则钩子就不会被 <span class="selector-tag">resolved</span>。</span><br><span class="line"></span><br><span class="line">#全局解析守卫</span><br><span class="line">2.5.0 新增</span><br><span class="line"></span><br><span class="line">在 2.5.0+ 你可以用 <span class="selector-tag">router</span><span class="selector-class">.beforeResolve</span> 注册一个全局守卫。这和 <span class="selector-tag">router</span><span class="selector-class">.beforeEach</span> 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</span><br><span class="line"></span><br><span class="line">#全局后置钩子</span><br><span class="line">你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <span class="selector-tag">next</span> 函数也不会改变导航本身：</span><br><span class="line"></span><br><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">#路由独享的守卫</span><br><span class="line">你可以在路由配置上直接定义 <span class="selector-tag">beforeEnter</span> 守卫：</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attribute">path</span>: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">这些守卫与全局前置守卫的方法参数是一样的。</span><br><span class="line"></span><br><span class="line">#组件内的守卫</span><br><span class="line">最后，你可以在路由组件内直接定义以下路由导航守卫：</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">beforeRouteEnter</span></span><br><span class="line"><span class="selector-tag">beforeRouteUpdate</span> (2.2 新增)</span><br><span class="line"><span class="selector-tag">beforeRouteLeave</span></span><br><span class="line">const Foo = &#123;</span><br><span class="line">  <span class="selector-tag">template</span>: `...`,</span><br><span class="line">  <span class="selector-tag">beforeRouteEnter</span> (<span class="selector-tag">to</span>, <span class="selector-tag">from</span>, <span class="selector-tag">next</span>) &#123;</span><br><span class="line">    // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    // 不！能！获取组件实例 `<span class="selector-tag">this</span>`</span><br><span class="line">    // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="selector-tag">beforeRouteUpdate</span> (<span class="selector-tag">to</span>, <span class="selector-tag">from</span>, <span class="selector-tag">next</span>) &#123;</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 /<span class="selector-tag">foo</span>/<span class="selector-pseudo">:id</span>，在 /<span class="selector-tag">foo</span>/1 和 /<span class="selector-tag">foo</span>/2 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 <span class="selector-tag">Foo</span> 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    // 可以访问组件实例 `<span class="selector-tag">this</span>`</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="selector-tag">beforeRouteLeave</span> (<span class="selector-tag">to</span>, <span class="selector-tag">from</span>, <span class="selector-tag">next</span>) &#123;</span><br><span class="line">    // 导航离开该组件的对应路由时调用</span><br><span class="line">    // 可以访问组件实例 `<span class="selector-tag">this</span>`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">beforeRouteEnter</span> 守卫 不能 访问 <span class="selector-tag">this</span>，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</span><br><span class="line"></span><br><span class="line">不过，你可以通过传一个回调给 <span class="selector-tag">next</span>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">beforeRouteEnter</span> (<span class="selector-tag">to</span>, <span class="selector-tag">from</span>, <span class="selector-tag">next</span>) &#123;</span><br><span class="line">  next(vm =&gt; &#123;</span><br><span class="line">    // 通过 `<span class="selector-tag">vm</span>` 访问组件实例</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">注意 <span class="selector-tag">beforeRouteEnter</span> 是支持给 <span class="selector-tag">next</span> 传递回调的唯一守卫。对于 <span class="selector-tag">beforeRouteUpdate</span> 和 <span class="selector-tag">beforeRouteLeave</span> 来说，<span class="selector-tag">this</span> 已经可用了，所以不支持传递回调，因为没有必要了。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">beforeRouteUpdate</span> (<span class="selector-tag">to</span>, <span class="selector-tag">from</span>, <span class="selector-tag">next</span>) &#123;</span><br><span class="line">  // just use `this`</span><br><span class="line">  this.name = to.params.name</span><br><span class="line">  <span class="selector-tag">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <span class="selector-tag">next</span>(<span class="selector-tag">false</span>) 来取消。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">beforeRouteLeave</span> (<span class="selector-tag">to</span>, <span class="selector-tag">from</span>, <span class="selector-tag">next</span>) &#123;</span><br><span class="line">  const answer = window.confirm(&#x27;Do you really want to leave? you have unsaved changes!&#x27;)</span><br><span class="line">  <span class="selector-tag">if</span> (<span class="selector-tag">answer</span>) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">    next(false)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#完整的导航解析流程</span><br><span class="line">导航被触发。</span><br><span class="line">在失活的组件里调用离开守卫。</span><br><span class="line">调用全局的 <span class="selector-tag">beforeEach</span> 守卫。</span><br><span class="line">在重用的组件里调用 <span class="selector-tag">beforeRouteUpdate</span> 守卫 (2.2+)。</span><br><span class="line">在路由配置里调用 <span class="selector-tag">beforeEnter</span>。</span><br><span class="line">解析异步路由组件。</span><br><span class="line">在被激活的组件里调用 <span class="selector-tag">beforeRouteEnter</span>。</span><br><span class="line">调用全局的 <span class="selector-tag">beforeResolve</span> 守卫 (2.5+)。</span><br><span class="line">导航被确认。</span><br><span class="line">调用全局的 <span class="selector-tag">afterEach</span> 钩子。</span><br><span class="line">触发 <span class="selector-tag">DOM</span> 更新。</span><br><span class="line">用创建好的实例调用 <span class="selector-tag">beforeRouteEnter</span> 守卫中传给 <span class="selector-tag">next</span> 的回调函数。</span><br></pre></td></tr></table></figure></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/taiaiac.gitee.io/taiaiac.gitee.io/tags#vue" >
    <span class="tag-code">vue</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/taiaiac.gitee.io/2020/12/30/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">
        <span class="nav-arrow">← </span>
        
          前端开发规范
        
      </a>
    
    
      <a class="nav-right" href="/taiaiac.gitee.io/2020/12/30/vue/ESLint%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/">
        
          ESlint使用简介
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-nav-text">一、前言</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%BA%8C%E3%80%81vue-router-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-nav-text">二、vue-router 是什么</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%B8%89%E3%80%81vue-router-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-nav-text">三、vue-router 实现原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1%E3%80%81Hash-%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-nav-text">1、Hash 模式：</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2%E3%80%81History-%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-nav-text">2、History 模式：</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">3、使用路由模块来实现页面跳转的方式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%9B%9B%E3%80%81vue-router-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">四、vue-router 使用方式</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%BA%94%E3%80%81-vue-router-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-nav-text">五、 vue-router 参数传递</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E7%94%A8-name-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-nav-text">1.用 name 传递参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E9%80%9A%E8%BF%87-lt-router-link-gt-%E6%A0%87%E7%AD%BE%E4%B8%AD%E7%9A%84-to-%E4%BC%A0%E5%8F%82"><span class="toc-nav-text">2 通过&lt;router-link&gt; 标签中的 to 传参</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E5%88%A9%E7%94%A8-url-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E2%80%94-%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8C%E4%BB%A5%E5%86%92%E5%8F%B7%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E3%80%82"><span class="toc-nav-text">3 利用 url 传递参数—-在配置文件里以冒号的形式设置参数。</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E4%BD%BF%E7%94%A8-path-%E6%9D%A5%E5%8C%B9%E9%85%8D%E8%B7%AF%E7%94%B1%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87-query-%E6%9D%A5%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-nav-text">4. 使用 path 来匹配路由，然后通过 query 来传递参数</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%85%AD%E3%80%81vue-router-%E9%85%8D%E7%BD%AE%E5%AD%90%E8%B7%AF%E7%94%B1-%E4%BA%8C%E7%BA%A7%E8%B7%AF%E7%94%B1"><span class="toc-nav-text">六、vue-router 配置子路由(二级路由)</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%B8%83%E3%80%81%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%A4%9A%E8%B7%AF%E7%94%B1%E5%8C%BA%E5%9F%9F%E6%93%8D%E4%BD%9C"><span class="toc-nav-text">七、单页面多路由区域操作</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%85%AB-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">八.$route 和 $router 的区别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%B9%9D%E3%80%81-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE-404-%E9%A1%B5%E9%9D%A2"><span class="toc-nav-text">九、 如何设置 404 页面</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%8D%81%E3%80%81%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-nav-text">十、路由守卫</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-nav-text">1.导航守卫是什么</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E5%85%A8%E8%A7%A3%E6%9E%90"><span class="toc-nav-text">2.导航守卫全解析</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0"><span class="toc-nav-text">3.导航守卫回调参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-nav-text">4.总结</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://gitee.com/aidemin/taiaiac.gitee.io.git/2020/12/30/vue/vue-router/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>



  <script>
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "vue-router",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/taiaiac.gitee.io/js/script.js"></script>

  <script src="/taiaiac.gitee.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/taiaiac.gitee.io/live2dw/assets/hibiki.model.json"},"display":{"position":"left","width":200,"height":434},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>